<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MiniGolf Pro - Multiplayer Edition</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --accent-color: #10b981;
            --ui-bg: #1e293b;
            --player1-color: #3b82f6;
            --player2-color: #ef4444;
        }

        body {
            background: var(--bg-color);
            color: white;
            font-family: 'Plus Jakarta Sans', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px 10px 100px 10px;
            overflow-y: auto;
            user-select: none;
        }

        h1 { margin: 10px 0; text-transform: uppercase; letter-spacing: 4px; font-weight: 900; }

        #multiplayer-lobby {
            background: var(--ui-bg);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            border: 1px solid #334155;
            text-align: center;
            width: 800px;
        }

        .lobby-controls { display: flex; gap: 10px; justify-content: center; margin-top: 10px; }
        
        input {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #475569;
            background: #0f172a;
            color: white;
            font-weight: bold;
        }

        #game-header {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
            align-items: center;
            width: 800px;
            justify-content: space-between;
        }

        .level-indicator {
            padding: 8px 20px;
            border-radius: 12px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            font-weight: bold;
            color: var(--accent-color);
        }

        #game-container { position: relative; border-radius: 20px; overflow: hidden; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); display: none; }

        canvas { background: #111; display: block; cursor: crosshair; }

        .controls {
            display: flex;
            gap: 40px;
            background: var(--ui-bg);
            padding: 25px 40px;
            border-radius: 0 0 25px 25px;
            align-items: center;
            border: 1px solid #334155;
            width: fit-content;
            margin-top: -5px;
            margin-bottom: 40px;
            display: none;
        }

        .gauge-container {
            background: #020617;
            border: 2px solid #334155;
            position: relative;
            overflow: hidden;
            border-radius: 10px;
        }

        #power-gauge-ui { width: 45px; height: 110px; display: flex; flex-direction: column-reverse; }
        
        .bar { position: absolute; transition: 0.05s ease-out; }
        #power-bar {
            width: 100%; bottom: 0; height: 0%;
            background: linear-gradient(to top, #10b981, #facc15, #ef4444);
        }

        .active { border-color: var(--accent-color); box-shadow: 0 0 20px rgba(16, 185, 129, 0.3); }
        .label { text-align: center; font-size: 11px; font-weight: 800; margin-bottom: 6px; color: #64748b; letter-spacing: 1px; }

        #turn-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 30px;
            border-radius: 50px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: rgba(0,0,0,0.7);
            border: 2px solid white;
            z-index: 50;
        }

        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(2, 6, 23, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            display: none;
            backdrop-filter: blur(5px);
        }

        button {
            background: var(--accent-color);
            color: #022c22;
            border: none;
            padding: 12px 25px;
            border-radius: 10px;
            font-weight: 800;
            cursor: pointer;
            transition: 0.2s;
        }

        button:hover { opacity: 0.9; transform: translateY(-2px); }
        button:disabled { background: #475569; cursor: not-allowed; }

        #score-display { font-size: 18px; font-weight: 900; color: #fff; background: rgba(255,255,255,0.05); padding: 5px 15px; border-radius: 10px; }
    </style>
</head>
<body>

    <h1>MINIGOLF <span id="title-accent" style="color:#10b981">MULTIPLAYER</span></h1>

    <div id="multiplayer-lobby">
        <h3 style="margin-top:0">ðŸŽ® SALON MULTIJOUEUR</h3>
        <p id="lobby-status">Connectez-vous pour commencer...</p>
        <div class="lobby-controls">
            <input type="text" id="room-id" placeholder="CODE DE SALLE (ex: 1234)">
            <button id="btn-join" onclick="joinRoom()">REJOINDRE / CRÃ‰ER</button>
        </div>
        <div id="user-id-display" style="margin-top: 10px; font-size: 12px; opacity: 0.5;"></div>
    </div>

    <div id="game-header" style="display: none;">
        <div id="level-name" class="level-indicator">ATTENTE DU JOUEUR 2...</div>
        <div id="score-display">P1: 0 | P2: 0</div>
    </div>

    <div id="game-container">
        <div id="turn-indicator">ATTENTE...</div>
        <canvas id="golfCanvas" width="800" height="450"></canvas>
        
        <div id="overlay">
            <h2 id="overlay-title" style="font-size: 40px; color: gold; margin: 0;">TERMINÃ‰ !</h2>
            <p id="overlay-stats" style="font-size: 20px;"></p>
            <button id="next-btn">NIVEAU SUIVANT</button>
        </div>
    </div>

    <div class="controls" id="game-controls">
        <div>
            <div class="label">PUISSANCE</div>
            <div id="power-gauge-ui" class="gauge-container">
                <div id="power-bar" class="bar"></div>
            </div>
        </div>
        <div id="instruction-hint" style="color: #94a3b8; font-size: 14px;">
            <strong>VOTRE RÃ”LE :</strong> <span id="player-role-display">-</span><br>
            Attendez votre tour pour tirer.
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // CONFIGURATION FIREBASE
        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'minigolf-multi';

        // Ã‰TAT DU JEU
        let user = null;
        let roomData = null;
        let myPlayerNum = null; // 1 ou 2
        let currentLevelIndex = 0;
        let gameState = "LOBBY"; 

        // CONFIG DES NIVEAUX (SimplifiÃ© pour le multijoueur)
        const LEVELS = [
            { name: "GREEN ARENA", start: {x: 100, y: 225}, hole: {x: 700, y: 225}, walls: [{x:385, y:100, w:30, h:250}] },
            { name: "TWIN WALLS", start: {x: 80, y: 80}, hole: {x: 720, y: 370}, walls: [{x:220, y:0, w:30, h:300}, {x:550, y:150, w:30, h:300}] }
        ];

        // Ã‰LÃ‰MENTS DU JEU
        const canvas = document.getElementById('golfCanvas');
        const ctx = canvas.getContext('2d');
        const powerBar = document.getElementById('power-bar');
        
        let ballP1 = { x: 0, y: 0, vx: 0, vy: 0, score: 0, active: true };
        let ballP2 = { x: 0, y: 0, vx: 0, vy: 0, score: 0, active: true };
        let mouseX = 0, mouseY = 0, powerVal = 0, isCharging = false;

        // AUTHENTIFICATION
        const initAuth = async () => {
            await signInAnonymously(auth);
            onAuthStateChanged(auth, (u) => {
                user = u;
                if(user) {
                    document.getElementById('lobby-status').textContent = "ConnectÃ©. Entrez un code pour jouer.";
                    document.getElementById('user-id-display').textContent = `Votre ID : ${user.uid}`;
                }
            });
        };
        initAuth();

        // LOGIQUE MULTIJOUEUR
        window.joinRoom = async () => {
            const roomId = document.getElementById('room-id').value.trim();
            if (!roomId || !user) return;

            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId);
            const roomSnap = await getDoc(roomRef);

            if (!roomSnap.exists()) {
                // CrÃ©er la salle
                myPlayerNum = 1;
                const initialData = {
                    p1: user.uid,
                    p2: null,
                    turn: 1,
                    levelIndex: 0,
                    p1Pos: { x: LEVELS[0].start.x, y: LEVELS[0].start.y },
                    p2Pos: { x: LEVELS[0].start.x, y: LEVELS[0].start.y },
                    p1Score: 0,
                    p2Score: 0,
                    lastShot: null,
                    status: "waiting"
                };
                await setDoc(roomRef, initialData);
            } else {
                const data = roomSnap.data();
                if (data.p1 === user.uid) {
                    myPlayerNum = 1;
                } else if (!data.p2 || data.p2 === user.uid) {
                    myPlayerNum = 2;
                    await updateDoc(roomRef, { p2: user.uid, status: "playing" });
                } else {
                    alert("Salle pleine !");
                    return;
                }
            }

            document.getElementById('multiplayer-lobby').style.display = "none";
            document.getElementById('game-container').style.display = "block";
            document.getElementById('game-header').style.display = "flex";
            document.getElementById('game-controls').style.display = "flex";
            document.getElementById('player-role-display').textContent = "JOUEUR " + myPlayerNum;
            document.getElementById('player-role-display').style.color = myPlayerNum === 1 ? 'var(--player1-color)' : 'var(--player2-color)';

            // Ã‰couter les changements de la salle
            onSnapshot(roomRef, (doc) => {
                if(doc.exists()) syncRoom(doc.data());
            }, (err) => console.error("Erreur Sync:", err));
        };

        function syncRoom(data) {
            roomData = data;
            currentLevelIndex = data.levelIndex;
            
            // Sync positions (seulement si on ne bouge pas localement pour Ã©viter les saccades)
            if (gameState !== "MOVING") {
                ballP1.x = data.p1Pos.x; ballP1.y = data.p1Pos.y;
                ballP2.x = data.p2Pos.x; ballP2.y = data.p2Pos.y;
            }

            document.getElementById('score-display').textContent = `P1: ${data.p1Score} | P2: ${data.p2Score}`;
            document.getElementById('level-name').textContent = data.status === "waiting" ? "ATTENTE JOUEUR 2..." : LEVELS[currentLevelIndex].name;
            
            const indicator = document.getElementById('turn-indicator');
            if (data.status === "waiting") {
                indicator.textContent = "EN ATTENTE...";
                indicator.style.borderColor = "white";
            } else {
                indicator.textContent = data.turn === myPlayerNum ? "C'EST VOTRE TOUR !" : "TOUR DE L'ADVERSAIRE";
                indicator.style.borderColor = data.turn === 1 ? 'var(--player1-color)' : 'var(--player2-color)';
            }
        }

        // BOUCLE DE JEU
        function update() {
            if (!roomData || roomData.status !== "playing") {
                draw();
                requestAnimationFrame(update);
                return;
            }

            const level = LEVELS[currentLevelIndex];
            
            if (gameState === "MOVING") {
                const b = myPlayerNum === 1 ? ballP1 : ballP2;
                b.x += b.vx; b.y += b.vy;
                b.vx *= 0.985; b.vy *= 0.985;

                // Collisions murs simples
                level.walls.forEach(w => {
                    if (b.x + 8 > w.x && b.x - 8 < w.x + w.w && b.y + 8 > w.y && b.y - 8 < w.y + w.h) {
                        b.vx *= -0.8; b.vy *= -0.8;
                    }
                });

                // Trou
                let dist = Math.hypot(b.x - level.hole.x, b.y - level.hole.y);
                if (dist < 15 && Math.hypot(b.vx, b.vy) < 3) {
                    finishTurn(true);
                }

                if (Math.abs(b.vx) < 0.1 && Math.abs(b.vy) < 0.1) {
                    finishTurn(false);
                }
            }

            draw();
            requestAnimationFrame(update);
        }

        async function finishTurn(inHole) {
            gameState = "WAITING";
            const roomId = document.getElementById('room-id').value.trim();
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId);
            
            const updateObj = {};
            if (myPlayerNum === 1) {
                updateObj.p1Pos = { x: ballP1.x, y: ballP1.y };
                if (inHole) {
                    updateObj.p1Pos = LEVELS[currentLevelIndex].hole;
                }
            } else {
                updateObj.p2Pos = { x: ballP2.x, y: ballP2.y };
                if (inHole) {
                    updateObj.p2Pos = LEVELS[currentLevelIndex].hole;
                }
            }

            // Changer de tour
            updateObj.turn = roomData.turn === 1 ? 2 : 1;
            await updateDoc(roomRef, updateObj);
        }

        function draw() {
            ctx.fillStyle = "#15803d";
            ctx.fillRect(0,0,800,450);

            if (!roomData) return;
            const level = LEVELS[currentLevelIndex];

            // Trou
            ctx.fillStyle = "black";
            ctx.beginPath(); ctx.arc(level.hole.x, level.hole.y, 15, 0, Math.PI*2); ctx.fill();

            // Murs
            ctx.fillStyle = "#5d4037";
            level.walls.forEach(w => ctx.fillRect(w.x, w.y, w.w, w.h));

            // Balle P1
            ctx.fillStyle = 'var(--player1-color)';
            ctx.beginPath(); ctx.arc(ballP1.x, ballP1.y, 8, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = "white"; ctx.stroke();

            // Balle P2
            ctx.fillStyle = 'var(--player2-color)';
            ctx.beginPath(); ctx.arc(ballP2.x, ballP2.y, 8, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = "white"; ctx.stroke();

            // Ligne de visÃ©e (seulement si c'est notre tour)
            if (roomData.turn === myPlayerNum && gameState !== "MOVING") {
                const b = myPlayerNum === 1 ? ballP1 : ballP2;
                ctx.beginPath();
                ctx.strokeStyle = "white";
                ctx.setLineDash([5, 5]);
                ctx.moveTo(b.x, b.y);
                ctx.lineTo(mouseX, mouseY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // INPUTS
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', () => {
            if (roomData && roomData.turn === myPlayerNum && gameState === "WAITING") {
                isCharging = true;
                powerVal = 0;
                chargePower();
            }
        });

        window.addEventListener('mouseup', async () => {
            if (isCharging) {
                isCharging = false;
                shoot();
            }
        });

        function chargePower() {
            if (!isCharging) return;
            powerVal = Math.min(100, powerVal + 2);
            powerBar.style.height = powerVal + "%";
            requestAnimationFrame(chargePower);
        }

        async function shoot() {
            gameState = "MOVING";
            const b = myPlayerNum === 1 ? ballP1 : ballP2;
            const angle = Math.atan2(mouseY - b.y, mouseX - b.x);
            const force = powerVal / 5;
            b.vx = Math.cos(angle) * force;
            b.vy = Math.sin(angle) * force;

            const roomId = document.getElementById('room-id').value.trim();
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId);
            
            // Update score
            if (myPlayerNum === 1) await updateDoc(roomRef, { p1Score: roomData.p1Score + 1 });
            else await updateDoc(roomRef, { p2Score: roomData.p2Score + 1 });
        }

        requestAnimationFrame(update);
    </script>
</body>
</html>
