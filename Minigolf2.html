<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>MiniGolf Pro - 3 Bisques Corrigé</title>
    <style>
        body {
            background: #222;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 5px 10px 10px 10px; /* un peu moins de padding top pour remonter les jauges */
        }
        h1 { margin: 5px 0; color: #4caf50; text-shadow: 2px 2px #000; font-size: 24px; }
        
        /* Contrôles placés en haut (remontés) */
        .controls {
            display: flex;
            gap: 40px;
            margin-bottom: 15px;
            background: #333;
            padding: 15px 30px;
            border-radius: 15px;
            align-items: flex-end; /* Aligne les jauges par le bas */
            border: 2px solid #444;
            position: relative;
            top: -12px; /* remonte légèrement les jauges */
        }

        #score-display {
            font-size: 20px;
            background: #4caf50;
            padding: 5px 20px;
            border-radius: 20px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .gauge-container {
            background: #111;
            border: 2px solid #888;
            position: relative;
            overflow: hidden;
            border-radius: 5px;
        }
        #power-gauge-ui { width: 40px; height: 100px; display: flex; flex-direction: column-reverse; }
        #direction-gauge-ui { width: 150px; height: 30px; }
        
        .bar { position: absolute; }
        #power-bar {
            width: 100%; bottom: 0; height: 0%;
            background: linear-gradient(to top, #4caf50, #ffeb3b, #f44336);
        }
        #direction-bar {
            height: 100%; left: 0; width: 8px;
            background: #2196f3; box-shadow: 0 0 5px #2196f3;
        }
        .active { border-color: #00ff00; box-shadow: 0 0 15px #00ff00; }
        .label { text-align: center; font-size: 12px; font-weight: bold; margin-bottom: 5px; color: #eee; }

        #game-container { position: relative; margin-top: 12px; } /* espace pour éviter chevauchement */
        canvas {
            background: linear-gradient(135deg, #2e7d32 0%, #1b5e20 100%);
            border: 8px solid #5d4037;
            border-radius: 15px;
        }
        
        #success-message {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: gold;
            font-size: 28px;
            padding: 25px;
            border-radius: 20px;
            display: none;
            text-align: center;
            border: 3px solid gold;
            z-index: 10;
        }
        button {
            margin-top: 15px;
            padding: 10px 20px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <h1>MINIGOLF PRO</h1>
    
    <div class="controls">
        <div>
            <div class="label">PUISSANCE</div>
            <div id="power-gauge-ui" class="gauge-container">
                <div id="power-bar" class="bar"></div>
            </div>
        </div>
        <div>
            <div id="score-display">COUPS : 0</div>
            <div class="label">ANGLE</div>
            <div id="direction-gauge-ui" class="gauge-container">
                <div id="direction-bar" class="bar"></div>
            </div>
        </div>
    </div>

    <div id="game-container">
        <canvas id="golfCanvas" width="800" height="400"></canvas>
        <div id="success-message">
            BIEN JOUÉ !<br>
            <span id="final-shots" style="font-size: 20px; color: white;"></span><br>
            <button onclick="resetBall()">REJOUER</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('golfCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const successMessage = document.getElementById('success-message');
        const finalShotsText = document.getElementById('final-shots');

        let ball = { x: 80, y: 200, r: 8, vx: 0, vy: 0, friction: 0.985 };
        let hole = { x: 720, y: 200, r: 14 };

        // Obstacles : murs verticaux (les positions restent, la physique empêche désormais le passage)
        let obstacles = [
            { x: 250, y: 0, w: 30, h: 220 },
            { x: 420, y: 180, w: 30, h: 220 },
            { x: 580, y: 0, w: 30, h: 220 }
        ];
        
        let shots = 0;
        let gameState = "WAITING"; 
        let powerVal = 0; let powerDir = 1;
        let dirVal = 50; let dirSwap = 1;

        function update() {
            if (gameState === "POWER") {
                powerVal += 2 * powerDir;
                if (powerVal >= 100 || powerVal <= 0) powerDir *= -1;
                document.getElementById('power-bar').style.height = powerVal + "%";
            } 
            else if (gameState === "DIRECTION") {
                dirVal += 2.5 * dirSwap;
                if (dirVal >= 100 || dirVal <= 0) dirSwap *= -1;
                document.getElementById('direction-bar').style.left = dirVal + "%";
            }
            else if (gameState === "MOVING") {
                ball.x += ball.vx;
                ball.y += ball.vy;
                ball.vx *= ball.friction;
                ball.vy *= ball.friction;

                // Murs extérieurs
                if (ball.x < ball.r || ball.x > canvas.width - ball.r) {
                    ball.vx *= -0.8;
                    ball.x = ball.x < ball.r ? ball.r : canvas.width - ball.r;
                }
                if (ball.y < ball.r || ball.y > canvas.height - ball.r) {
                    ball.vy *= -0.8;
                    ball.y = ball.y < ball.r ? ball.r : canvas.height - ball.r;
                }

                // PHYSIQUE DES MURS D'OBSTACLES (RÉSOLUTION PAR NORMAL + RÉFLEXION)
                obstacles.forEach(obs => {
                    // trouver le point le plus proche sur le rectangle
                    let closestX = Math.max(obs.x, Math.min(ball.x, obs.x + obs.w));
                    let closestY = Math.max(obs.y, Math.min(ball.y, obs.y + obs.h));
                    let distanceX = ball.x - closestX;
                    let distanceY = ball.y - closestY;
                    let distanceSquared = (distanceX * distanceX) + (distanceY * distanceY);

                    if (distanceSquared < (ball.r * ball.r)) {
                        let distance = Math.sqrt(distanceSquared) || 0.0001; // éviter division par 0
                        // normale du contact (de l'obstacle vers la balle)
                        let nx = distanceX / distance;
                        let ny = distanceY / distance;
                        // profondeur de pénétration
                        let penetration = ball.r - distance;
                        // déplacer la balle hors de l'obstacle le long de la normale
                        ball.x += nx * (penetration + 0.5);
                        ball.y += ny * (penetration + 0.5);

                        // réflexection de la vélocité selon la normale (coefficient de rebond 0.8)
                        let vDotN = ball.vx * nx + ball.vy * ny;
                        // retirer la composante normale et inverser avec amortissement
                        ball.vx -= (1.8 * vDotN) * nx;
                        ball.vy -= (1.8 * vDotN) * ny;

                        // petit correctif pour empêcher "coller" à l'obstacle
                        if (Math.abs(ball.vx) < 0.05) ball.vx = 0;
                        if (Math.abs(ball.vy) < 0.05) ball.vy = 0;
                    }
                });

                // Trou
                let dist = Math.hypot(ball.x - hole.x, ball.y - hole.y);
                if (dist < hole.r && Math.hypot(ball.vx, ball.vy) < 4) {
                    gameState = "HOLE";
                    ball.vx = 0; ball.vy = 0;
                    successMessage.style.display = "block";
                    finalShotsText.textContent = `Terminé en ${shots} coups !`;
                }

                if (Math.abs(ball.vx) < 0.15 && Math.abs(ball.vy) < 0.15) {
                    ball.vx = 0; ball.vy = 0;
                    if (gameState !== "HOLE") gameState = "WAITING";
                }
            }
            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Herbe
            ctx.fillStyle = "rgba(255, 255, 255, 0.05)";
            for (let i = 0; i < canvas.width; i += 40) ctx.fillRect(i, 0, 20, canvas.height);

            // Trou
            ctx.fillStyle = "#111";
            ctx.beginPath(); ctx.arc(hole.x, hole.y, hole.r, 0, Math.PI * 2); ctx.fill();
            
            // Obstacles (Murs)
            ctx.fillStyle = "#5d4037";
            obstacles.forEach(obs => {
                ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                ctx.strokeStyle = "#3e2723";
                ctx.lineWidth = 2;
                ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
            });

            // Visée
            if (gameState === "DIRECTION" || gameState === "POWER") {
                ctx.beginPath();
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                ctx.moveTo(ball.x, ball.y);
                let angle = (dirVal - 50) * 0.035; 
                ctx.lineTo(ball.x + 80, ball.y + (angle * 180));
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Balle
            ctx.fillStyle = "white";
            ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2); ctx.fill();
        }

        window.addEventListener('mousedown', () => {
            if (gameState === "HOLE") return;
            if (gameState === "WAITING") {
                gameState = "POWER";
                document.getElementById('power-gauge-ui').classList.add('active');
            } 
            else if (gameState === "POWER") {
                gameState = "DIRECTION";
                document.getElementById('power-gauge-ui').classList.remove('active');
                document.getElementById('direction-gauge-ui').classList.add('active');
            }
            else if (gameState === "DIRECTION") {
                document.getElementById('direction-gauge-ui').classList.remove('active');
                shots++;
                scoreDisplay.textContent = `COUPS : ${shots}`;
                ball.vx = (powerVal / 5) + 2;
                ball.vy = ((dirVal - 50) * 0.035) * ball.vx;
                gameState = "MOVING";
            }
        });

        function resetBall() {
            ball.x = 80; ball.y = 200;
            ball.vx = 0; ball.vy = 0;
            shots = 0;
            scoreDisplay.textContent = `COUPS : 0`;
            gameState = "WAITING";
            successMessage.style.display = "none";
            powerVal = 0; dirVal = 50;
            document.getElementById('power-bar').style.height = "0%";
        }

        update();
    </script>
</body>
</html>
